import os
import logging
import warnings
from pathlib import Path
from io import StringIO
import requests
import yaml
import pandas as pd
import pypdb
from prody import *
from rdkit import Chem
from rdkit.Chem import AllChem
from Bio.PDB import PDBParser
from boltz.data.msa.mmseqs2 import run_mmseqs2
from boltz.data.parse.a3m import parse_a3m
from prody import parsePDB


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class Config:
    def __init__(self, main_dir: str = None):
        self.CUDA_DEVICE = "1"
        if main_dir is None:
            self.MAIN_DIR = Path.cwd() / 'inputs'
        else:
            self.MAIN_DIR = Path(main_dir)
        self.PDB_DIR = self.MAIN_DIR / 'PDB'
        self.MSA_DIR = self.MAIN_DIR / 'MSA'
        self.YAML_DIR = self.MAIN_DIR / 'yaml'
        self.DESIGN_DIR = self.MAIN_DIR / 'designs'

    def setup_directories(self):
        """Create necessary directories if they don't exist."""
        for directory in [self.MAIN_DIR, self.PDB_DIR, self.MSA_DIR, self.YAML_DIR, self.DESIGN_DIR]:
            directory.mkdir(parents=True, exist_ok=True)


# Utility functions
def download_pdb(pdb_code: str, save_path: Path) -> bool:
    """Download PDB file from RCSB.
    
    Args:
        pdb_code: PDB identifier
        save_path: Directory to save the PDB file
        
    Returns:
        bool: True if download was successful, False otherwise
    """
    url = f"https://files.rcsb.org/download/{pdb_code}.pdb"
    try:
        response = requests.get(url)
        response.raise_for_status()
        
        file_path = save_path / f"{pdb_code}.pdb"
        file_path.write_text(response.text)
        logger.info(f"PDB file {pdb_code}.pdb downloaded successfully!")
        return True
    except requests.RequestException as e:
        logger.error(f"Failed to download {pdb_code}.pdb: {str(e)}")
        return False

def get_chains_sequence(pdb_path: Path) -> dict:
    """Extract protein sequences from PDB file.
    
    Args:
        pdb_path: Path to PDB file
        
    Returns:
        dict: Dictionary mapping chain IDs to sequences
    """
    aa_dict = {
        'ALA': 'A', 'CYS': 'C', 'ASP': 'D', 'GLU': 'E', 'PHE': 'F',
        'GLY': 'G', 'HIS': 'H', 'ILE': 'I', 'LYS': 'K', 'LEU': 'L',
        'MET': 'M', 'ASN': 'N', 'PRO': 'P', 'GLN': 'Q', 'ARG': 'R',
        'SER': 'S', 'THR': 'T', 'VAL': 'V', 'TRP': 'W', 'TYR': 'Y'
    }
    
    chain_sequences = {}
    prev_res_nums = {}
    
    try:
        with open(pdb_path, 'r') as f:
            for line in f:
                if line.startswith('ATOM'):
                    chain_id = line[21]
                    res_name = line[17:20].strip()
                    res_num = line[22:26].strip()
                    
                    if res_name not in aa_dict:
                        continue
                    
                    if chain_id not in chain_sequences:
                        chain_sequences[chain_id] = []
                        prev_res_nums[chain_id] = None
                    
                    if res_num != prev_res_nums[chain_id]:
                        chain_sequences[chain_id].append(aa_dict[res_name])
                        prev_res_nums[chain_id] = res_num
        
        return {chain: ''.join(seq) for chain, seq in chain_sequences.items()}
    except Exception as e:
        logger.error(f"Error processing PDB file {pdb_path}: {str(e)}")
        return {}


def get_pdb_components(pdb_id):
    """
    Split a protein-ligand pdb into protein and ligand components
    :param pdb_id:
    :return:
    """
    pdb = parsePDB(pdb_id)
    protein = pdb.select('protein')
    ligand = pdb.select('not protein and not water')
    return protein, ligand

def get_ligand_smiles(ligand, res_name):
    """
    Get SMILES string for a ligand from PDB
    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :return: SMILES string
    """
    sub_mol = ligand.select(f"resname {res_name}")
    chem_desc = pypdb.describe_chemical(f"{res_name}")
    
    # Extract SMILES from chemical description
    smiles = None
    for item in chem_desc.get('pdbx_chem_comp_descriptor', []):
        if item.get('type') == 'SMILES':
            smiles = item.get('descriptor')
            break
            
    return smiles

def get_ligand_from_pdb(pdb_name):
    """
    Get dictionary mapping ligand names to their SMILES strings from a PDB file
    :param pdb_name: id from the pdb, doesn't need to have an extension
    :return: dict mapping ligand residue names to SMILES strings
    """
    # Common ions and small molecules to ignore
    IGNORE_LIST = {'HOH', 'H2O', 'NA', 'CA', 'MG', 'CL', 'SO4', 'PO4', 'K', 'ZN', 'CU', 'FE', 'MN',
                   'NI', 'CO', 'CD', 'GOL', 'PEG', 'EDO', 'DMS', 'ACT', 'FMT', 'MES', 'HEM', 'TRS',
                   'ACE', 'BME', 'PGE', 'MPD', 'TLA', 'EOH', 'IPA', 'PCA', 'PG4', 'DTT', 'IMD'}
    
    _, ligand = get_pdb_components(pdb_name)
    res_name_list = list(set(ligand.getResnames()) - IGNORE_LIST)
    
    # If no valid ligands found
    if not res_name_list:
        return {}
    
    # Create dictionary mapping ligand names to SMILES strings
    ligand_dict = {}
    for res in res_name_list:
        smiles = get_ligand_smiles(ligand, res)
        if smiles:
            ligand_dict[res] = smiles
            
    return ligand_dict

def get_nucleotide_from_pdb(pdb_path):
    """Extract nucleotide sequence from PDB file"""
    parser = PDBParser(QUIET=True)  # Suppress PDB warnings
    pdb_code = os.path.basename(pdb_path).split('.')[0]
    structure = parser.get_structure(pdb_code, pdb_path)
    
    sequences = {}
    for chain in structure.get_chains():
        seq = ""
        is_dna = False
        for residue in chain:
            resname = residue.get_resname()
            if resname in ['DA', 'DT', 'DC', 'DG']:  # DNA nucleotides
                is_dna = True
                seq += resname[1]  # Remove the 'D' prefix
            elif resname in ['A', 'U', 'C', 'G']:  # RNA nucleotides
                seq += resname
        if seq:
            sequences[chain.id] = {'seq': seq, 'is_dna': is_dna}
            
    return sequences


def generate_yaml_from_pdb(pdb_code: str, target_type: str, config: Config, binder_id: str = 'A', target_ids: list = None, target_mols: str = None, constraints: dict = None, use_msa: bool = False):
    """Generate YAML from PDB file.
    Args:
        pdb_code: PDB identifier
        target_type: Type of target ('rna', 'dna', 'protein', 'small_molecule')
        config: Configuration object
        binder_id: Chain ID for the binder
        target_ids: List of target chain/residue IDs
    """
    download_pdb(pdb_code, config.PDB_DIR)
    pdb_path = config.PDB_DIR / f"{pdb_code}.pdb"
    
    target = []
    if target_type in ['rna', 'dna']:
        nucleotide_dict = get_nucleotide_from_pdb(pdb_path)
        for target_id in target_ids:
            target.append(nucleotide_dict[target_id]['seq'])
    elif target_type == 'small_molecule':
        ligand_dict = get_ligand_from_pdb(pdb_code)
        for target_mol in target_mols:
            target.append(ligand_dict[target_mol])
        else:
            target = list(ligand_dict.values())
    elif target_type == 'protein':
        chain_sequences = get_chains_sequence(pdb_path)
        for target_id in target_ids:
            target.append(chain_sequences[target_id])
    else:
        raise ValueError(f"Unsupported target type: {target_type}")
    return generate_yaml_for_taget_binder(pdb_code, target_type, target, config=config, binder_id=binder_id, constraints=constraints, use_msa=use_msa)

def generate_custom_yaml(target_name: str, target_type: str, target: list, config: Config, binder_id: str = 'A', constraints: dict = None, use_msa: bool = False):
    """Generate YAML with custom target sequence.
    
    Args:
        target_name: Name for the target
        target_type: Type of target ('rna', 'dna', 'protein', 'small_molecule')
        target: List containing target sequence or SMILES
        config: Configuration object
        binder_id: Chain ID for the binder
    """
    return generate_yaml_for_taget_binder(target_name, target_type, target, config=config, binder_id=binder_id, constraints=constraints, use_msa=use_msa)


def generate_yaml_for_taget_binder(name:str, type: str, targets: list, config="", binder_id='A', constraints: dict = None, use_msa: bool = False) -> dict:
    """
    Generate YAML content for a small molecule binder with multiple targets.
    
    Args:
        type (str): Type of ligand ('small_molecule', 'dna', 'rna', 'metal')
        targets (list): List of target information (SMILES, sequences, or CCD codes)
        binder_id (str): ID of the binder
        config (Config): Configuration object
        
    Returns:
        dict: YAML content dictionary
    """
    chain_dict = {}
    chain_dict[binder_id] = {
        'sequence': 'X' * 100,
    }

    # Add multiple ligands with sequential IDs

    for i, target in enumerate(targets):
        target_id = chr(ord('A') + i + 1)  # Start from B, C, D, etc.
        if type == 'protein':

            chain_dict[target_id] = {
                'type': 'protein',
                'id': target_id,
                'sequence': target,
                'msa': 'empty'
            }
        elif type == 'small_molecule':
            chain_dict[target_id] = {
                'type': 'ligand',
                'id': target_id,
                'smiles': target
            }
        elif type == 'dna':
            chain_dict[target_id] = {
                'type': 'dna',
                'id': target_id,
                'sequence': target
            }
        elif type == 'rna':
            chain_dict[target_id] = {
                'type': 'rna',
                'id': target_id,
                'sequence': target
            }
        elif type == 'metal':
            chain_dict[target_id] = {
                'type': 'metal',
                'id': target_id,
                'ccd': target
            }


    return create_yaml_file(
        pdb_code=name,
        chain_dict=chain_dict,
        config=config,
        use_msa=use_msa,
        constraints=constraints
    )

def create_yaml_file(pdb_code: str, chain_dict: dict, config: Config, use_msa: bool = False, constraints: list = None) -> bool:
    """Create YAML configuration file for protein chains, ligands, and nucleic acids.
    
    Args:
        pdb_code: PDB identifier
        chain_dict: Dictionary mapping chain IDs to sequences or sequence info dicts
        config: Configuration object
        msa_chains: List of chains that have MSA data
        constraints: Optional list of constraints to add to the YAML
    """
    sequences = []
    for chain_id, sequence in chain_dict.items():
        # Check if this is a ligand (SMILES string)
        is_ligand = isinstance(sequence, dict) and sequence.get('type') == 'ligand'
        
        # Check if this is a metal (CCD code)
        is_metal = isinstance(sequence, dict) and sequence.get('type') == 'metal'
        
        # Check if this is a nucleic acid sequence info dict
        is_nucleic = isinstance(sequence, dict) and sequence.get('type') in ['dna', 'rna']
    
        if is_ligand:
            sequences.append({
                "ligand": {
                    "id": [chain_id],
                    "smiles": sequence.get('smiles')
                }
            })
        elif is_metal:
            sequences.append({
                "ligand": {
                    "id": [chain_id],
                    "ccd": sequence.get('ccd')
                }
            })
        elif is_nucleic:
            sequences.append({
                sequence.get('type'): {
                    "id": [chain_id],
                    "sequence": sequence.get('sequence')
                }
            })
        else:
            msa_path = (config.MSA_DIR / f"{pdb_code}_{chain_id}_env/msa.npz" 
                       if use_msa and not all(x == 'X' for x in sequence.get('sequence')) else "empty")
            
            sequences.append({
                "protein": {
                    "id": [chain_id],
                    "sequence": sequence.get('sequence'),
                    "msa": str(msa_path)
                }
            })
    
    yaml_content = {
        "version": 1,
        "sequences": sequences
    }
    
    # Add constraints if provided
    if constraints:
        yaml_content["constraints"] = constraints
    
    output_path = config.YAML_DIR / f"{pdb_code}.yaml"
    with open(output_path, 'w') as f:
        yaml.dump(yaml_content, f, default_flow_style=False, sort_keys=False)
    logger.info(f"Created YAML file for {pdb_code}")
    return yaml_content, output_path


    
def process_msa(chain_id: str, sequence: str, pdb_code: str, config: Config) -> bool:
    """Process MSA for a single chain."""
    msa_chain_dir = config.MSA_DIR / f"{pdb_code}_{chain_id}"
    env_dir = msa_chain_dir.with_name(f"{msa_chain_dir.name}_env")
    env_dir.mkdir(exist_ok=True)
    
    # Run MSA
    unpaired_msa = run_mmseqs2(
        [sequence],
        str(msa_chain_dir),
        use_env=True,
        use_pairing=False,
        host_url="https://api.colabfold.com",
        pairing_strategy="greedy"
    )
    
    # Save MSA results
    msa_a3m_path = env_dir / "msa.a3m"
    msa_a3m_path.write_text(unpaired_msa[0])
    
    # Process MSA if not already processed
    msa_npz_path = env_dir / "msa.npz"
    if not msa_npz_path.exists():
        msa = parse_a3m(
            msa_a3m_path,
            taxonomy=None,
            max_seqs=4096,
        )
        msa.dump(msa_npz_path)
    
    logger.info(f"Processed MSA for {pdb_code} chain {chain_id}")
    return True