import os
import logging
import warnings
from pathlib import Path
from io import StringIO
import requests
import yaml
import pandas as pd
import pypdb
from prody import *
from rdkit import Chem
from rdkit.Chem import AllChem
from Bio.PDB import PDBParser
from boltz.data.msa.mmseqs2 import run_mmseqs2
from boltz.data.parse.a3m import parse_a3m
from prody import parsePDB


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class Config:
    def __init__(self, main_dir: str = None):
        self.CUDA_DEVICE = "1"
        if main_dir is None:
            self.MAIN_DIR = Path.cwd() / 'inputs'
        else:
            self.MAIN_DIR = Path(main_dir)
        self.PDB_DIR = self.MAIN_DIR / 'PDB'
        self.MSA_DIR = self.MAIN_DIR / 'MSA'
        self.YAML_DIR = self.MAIN_DIR / 'yaml'
        self.DESIGN_DIR = self.MAIN_DIR / 'designs'

    def setup_directories(self):
        """Create necessary directories if they don't exist."""
        for directory in [self.MAIN_DIR, self.PDB_DIR, self.MSA_DIR, self.YAML_DIR, self.DESIGN_DIR]:
            directory.mkdir(parents=True, exist_ok=True)


# Utility functions
def download_pdb(pdb_code: str, save_path: Path) -> bool:
    """Download PDB file from RCSB.
    
    Args:
        pdb_code: PDB identifier
        save_path: Directory to save the PDB file
        
    Returns:
        bool: True if download was successful, False otherwise
    """
    url = f"https://files.rcsb.org/download/{pdb_code}.pdb"
    try:
        response = requests.get(url)
        response.raise_for_status()
        
        file_path = save_path / f"{pdb_code}.pdb"
        file_path.write_text(response.text)
        logger.info(f"PDB file {pdb_code}.pdb downloaded successfully!")
        return True
    except requests.RequestException as e:
        logger.error(f"Failed to download {pdb_code}.pdb: {str(e)}")
        return False

def get_chains_sequence(pdb_path: Path) -> dict:
    """Extract protein sequences from PDB file.
    
    Args:
        pdb_path: Path to PDB file
        
    Returns:
        dict: Dictionary mapping chain IDs to sequences
    """
    aa_dict = {
        'ALA': 'A', 'CYS': 'C', 'ASP': 'D', 'GLU': 'E', 'PHE': 'F',
        'GLY': 'G', 'HIS': 'H', 'ILE': 'I', 'LYS': 'K', 'LEU': 'L',
        'MET': 'M', 'ASN': 'N', 'PRO': 'P', 'GLN': 'Q', 'ARG': 'R',
        'SER': 'S', 'THR': 'T', 'VAL': 'V', 'TRP': 'W', 'TYR': 'Y'
    }
    
    chain_sequences = {}
    prev_res_nums = {}
    
    try:
        with open(pdb_path, 'r') as f:
            for line in f:
                if line.startswith('ATOM'):
                    chain_id = line[21]
                    res_name = line[17:20].strip()
                    res_num = line[22:26].strip()
                    
                    if res_name not in aa_dict:
                        continue
                    
                    if chain_id not in chain_sequences:
                        chain_sequences[chain_id] = []
                        prev_res_nums[chain_id] = None
                    
                    if res_num != prev_res_nums[chain_id]:
                        chain_sequences[chain_id].append(aa_dict[res_name])
                        prev_res_nums[chain_id] = res_num
        
        return {chain: ''.join(seq) for chain, seq in chain_sequences.items()}
    except Exception as e:
        logger.error(f"Error processing PDB file {pdb_path}: {str(e)}")
        return {}


def get_pdb_components(pdb_id):
    """
    Split a protein-ligand pdb into protein and ligand components
    :param pdb_id:
    :return:
    """
    pdb = parsePDB(pdb_id)
    protein = pdb.select('protein')
    ligand = pdb.select('not protein and not water')
    return protein, ligand

def get_ligand_smiles(ligand, res_name):
    """
    Get SMILES string for a ligand from PDB
    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :return: SMILES string
    """
    sub_mol = ligand.select(f"resname {res_name}")
    chem_desc = pypdb.describe_chemical(f"{res_name}")
    
    # Extract SMILES from chemical description
    smiles = None
    for item in chem_desc.get('pdbx_chem_comp_descriptor', []):
        if item.get('type') == 'SMILES':
            smiles = item.get('descriptor')
            break
            
    return smiles

def get_ligand_from_pdb(pdb_name):
    """
    Get dictionary mapping ligand names to their SMILES strings from a PDB file
    :param pdb_name: id from the pdb, doesn't need to have an extension
    :return: dict mapping ligand residue names to SMILES strings
    """
    # Common ions and small molecules to ignore
    IGNORE_LIST = {'HOH', 'H2O', 'NA', 'CA', 'MG', 'CL', 'SO4', 'PO4', 'K', 'ZN', 'CU', 'FE', 'MN',
                   'NI', 'CO', 'CD', 'GOL', 'PEG', 'EDO', 'DMS', 'ACT', 'FMT', 'MES', 'HEM', 'TRS',
                   'ACE', 'BME', 'PGE', 'MPD', 'TLA', 'EOH', 'IPA', 'PCA', 'PG4', 'DTT', 'IMD'}
    
    _, ligand = get_pdb_components(pdb_name)
    res_name_list = list(set(ligand.getResnames()) - IGNORE_LIST)
    
    # If no valid ligands found
    if not res_name_list:
        return {}
    
    # Create dictionary mapping ligand names to SMILES strings
    ligand_dict = {}
    for res in res_name_list:
        smiles = get_ligand_smiles(ligand, res)
        if smiles:
            ligand_dict[res] = smiles
            
    return ligand_dict

def get_nucleotide_from_pdb(pdb_path):
    """Extract nucleotide sequence from PDB file"""
    parser = PDBParser(QUIET=True)  # Suppress PDB warnings
    pdb_code = os.path.basename(pdb_path).split('.')[0]
    structure = parser.get_structure(pdb_code, pdb_path)
    
    sequences = {}
    for chain in structure.get_chains():
        seq = ""
        is_dna = False
        for residue in chain:
            resname = residue.get_resname()
            if resname in ['DA', 'DT', 'DC', 'DG']:  # DNA nucleotides
                is_dna = True
                seq += resname[1]  # Remove the 'D' prefix
            elif resname in ['A', 'U', 'C', 'G']:  # RNA nucleotides
                seq += resname
        if seq:
            sequences[chain.id] = {'seq': seq, 'is_dna': is_dna}
            
    return sequences


def generate_yaml_from_pdb(pdb_code: str, target_type: str, config: Config, binder_id: str = 'A', target_ids: list = None, target_mols: str = None, constraints: dict = None, modifications: dict = None, use_msa: bool = False):
    """Generate YAML from PDB file.
    Args:
        pdb_code: PDB identifier
        target_type: Type of target ('rna', 'dna', 'protein', 'small_molecule')
        config: Configuration object
        binder_id: Chain ID for the binder
        target_ids: List of target chain/residue IDs
    """
    download_pdb(pdb_code, config.PDB_DIR)
    pdb_path = config.PDB_DIR / f"{pdb_code}.pdb"
    
    target = []
    if target_type in ['rna', 'dna']:
        nucleotide_dict = get_nucleotide_from_pdb(pdb_path)
        for target_id in target_ids:
            target.append(nucleotide_dict[target_id]['seq'])
    elif target_type == 'small_molecule':
        ligand_dict = get_ligand_from_pdb(pdb_code)
        for target_mol in target_mols:
            target.append(ligand_dict[target_mol])
        else:
            target = list(ligand_dict.values())
    elif target_type == 'protein':
        chain_sequences = get_chains_sequence(pdb_path)
        for target_id in target_ids:
            target.append(chain_sequences[target_id])
    else:
        raise ValueError(f"Unsupported target type: {target_type}")
    return generate_yaml_for_taget_binder(pdb_code, target_type, target, config=config, binder_id=binder_id, constraints=constraints, modifications=modifications, use_msa=use_msa)


def generate_custom_yaml(name:str, type: str, targets: list, config="", binder_id='A', constraints: dict = None, modifications: dict = None, use_msa: bool = False) -> dict:
    """
    Generate YAML content for a custom target binder with multiple targets and create the YAML file.
    """
    return generate_yaml_for_taget_binder(name, type, targets, config=config, binder_id=binder_id, constraints=constraints, modifications=modifications, use_msa=use_msa)

    
def generate_yaml_for_taget_binder(name:str, type: str, targets: list, config="", binder_id='A', constraints: dict = None, modifications: dict = None, use_msa: bool = False) -> dict:
    """
    Generate YAML content for a small molecule binder with multiple targets and create the YAML file.
    
    Args:
        name (str): Name/PDB code for the target
        type (str): Type of ligand ('small_molecule', 'dna', 'rna', 'metal', 'protein')
        targets (list): List of target information (SMILES, sequences, or CCD codes)
        binder_id (str): ID of the binder
        config (Config): Configuration object
        constraints (dict): Optional constraints to add to YAML
        modifications (dict): Optional modifications to add to YAML
        use_msa (bool): Whether to use MSA for proteins
        
    Returns:
        tuple: YAML content dictionary and output path
    """
    # Build chain dictionary
    chain_dict = {binder_id: {'type': 'protein', 'sequence': 'X' * 100}}

    # Map target types to their YAML representation
    type_map = {
        'protein': {'type': 'protein', 'sequence': True, 'msa': 'empty'},
        'small_molecule': {'type': 'ligand', 'smiles': True},
        'metal': {'type': 'ligand', 'ccd': True},
        'dna': {'type': 'dna', 'sequence': True},
        'rna': {'type': 'rna', 'sequence': True}
    }

    # Add targets with sequential IDs
    yaml_target_ids = []
    for i, target in enumerate(targets):
        target_id = chr(ord('A') + i + 1)  # Start from B, C, D, etc.
        yaml_target_ids.append(target_id)
        
        target_info = {'id': target_id}
        type_info = type_map[type]
        
        # Add appropriate fields based on target type
        for field, value in type_info.items():
            if value is True:
                target_info[field] = target
            elif value:
                target_info[field] = value
                
        chain_dict[target_id] = target_info

    # Build sequences list for YAML
    sequences = []
    for chain_id, info in chain_dict.items():
        if not isinstance(info, dict) or 'type' not in info:
            continue
            
        entry = {}
        if info['type'] == 'ligand':
            key = 'smiles' if 'smiles' in info else 'ccd'
            entry = {
                "ligand": {
                    "id": [chain_id],
                    key: info[key]
                }
            }
        elif info['type'] in ['dna', 'rna']:
            entry = {
                info['type']: {
                    "id": [chain_id],
                    "sequence": info['sequence']
                }
            }
        else:  # protein
            msa_path = (config.MSA_DIR / f"{name}_{chain_id}_env/msa.npz" 
                       if use_msa and not all(x == 'X' for x in info['sequence']) 
                       else "empty")

            if msa_path != "empty":
                process_msa(chain_id, info['sequence'], name, config)
                print(f"Processed MSA for {name} chain {chain_id}")
            
            entry = {
                "protein": {
                    "id": [chain_id],
                    "sequence": info['sequence'],
                    "msa": str(msa_path)
                }
            }
            
            if modifications and chain_id in yaml_target_ids:
                entry["protein"]["modifications"] = modifications
                
        sequences.append(entry)
    
    # Create and write YAML content
    yaml_content = {"version": 1, "sequences": sequences}
    if constraints:
        yaml_content["constraints"] = constraints

    output_path = config.YAML_DIR / f"{name}.yaml"
    with open(output_path, 'w') as f:
        yaml.dump(yaml_content, f, default_flow_style=False, sort_keys=False)
    logger.info(f"Created YAML file for {name}")
    
    return yaml_content, output_path

# def generate_yaml_for_taget_binder(name:str, type: str, targets: list, config="", binder_id='A', constraints: dict = None, modifications: dict = None, use_msa: bool = False) -> dict:
#     """
#     Generate YAML content for a small molecule binder with multiple targets and create the YAML file.
    
#     Args:
#         name (str): Name/PDB code for the target
#         type (str): Type of ligand ('small_molecule', 'dna', 'rna', 'metal', 'protein')
#         targets (list): List of target information (SMILES, sequences, or CCD codes)
#         binder_id (str): ID of the binder
#         config (Config): Configuration object
#         constraints (dict): Optional constraints to add to YAML
#         modifications (dict): Optional modifications to add to YAML
#         use_msa (bool): Whether to use MSA for proteins
        
#     Returns:
#         tuple: YAML content dictionary and output path
#     """
#     # Build chain dictionary
#     chain_dict = {}
#     chain_dict[binder_id] = {
#         'sequence': 'X' * 100,
#     }

#     # Add multiple targets with sequential IDs
#     yaml_target_ids = []
#     for i, target in enumerate(targets):
#         target_id = chr(ord('A') + i + 1)  # Start from B, C, D, etc.
#         yaml_target_ids.append(target_id)
        
#         chain_dict[target_id] = {
#             'id': target_id,
#             'sequence': target if type in ['protein', 'dna', 'rna'] else None,
#             'smiles': target if type == 'small_molecule' else None,
#             'ccd': target if type == 'metal' else None,
#             'type': {
#                 'protein': 'protein',
#                 'small_molecule': 'ligand', 
#                 'dna': 'dna',
#                 'rna': 'rna',
#                 'metal': 'metal'
#             }[type],
#             'msa': 'empty' if type == 'protein' else None
#         }
#         # Remove None values
#         chain_dict[target_id] = {k:v for k,v in chain_dict[target_id].items() if v is not None}

#     # Build sequences list for YAML
#     sequences = []
#     for chain_id, sequence in chain_dict.items():
#         if isinstance(sequence, dict):
#             if sequence.get('type') == 'ligand':
#                 sequences.append({
#                     "ligand": {
#                         "id": [chain_id],
#                         "smiles": sequence.get('smiles')
#                     }
#                 })
#             elif sequence.get('type') == 'metal':
#                 sequences.append({
#                     "ligand": {
#                         "id": [chain_id],
#                         "ccd": sequence.get('ccd')
#                     }
#                 })
#             elif sequence.get('type') in ['dna', 'rna']:
#                 sequences.append({
#                     sequence.get('type'): {
#                         "id": [chain_id],
#                         "sequence": sequence.get('sequence')
#                     }
#                 })
#             else:  # protein
#                 msa_path = (config.MSA_DIR / f"{name}_{chain_id}_env/msa.npz" 
#                            if use_msa and not all(x == 'X' for x in sequence.get('sequence')) else "empty")
                
#                 protein_dict = {
#                     "id": [chain_id],
#                     "sequence": sequence.get('sequence'), 
#                     "msa": str(msa_path)
#                 }

#                 if modifications and chain_id in yaml_target_ids:
#                     protein_dict["modifications"] = modifications
                    
#                 sequences.append({"protein": protein_dict})
    
#     # Create final YAML content
#     yaml_content = {
#         "version": 1,
#         "sequences": sequences
#     }
    
#     if constraints:
#         yaml_content["constraints"] = constraints

#     # Write YAML file
#     output_path = config.YAML_DIR / f"{name}.yaml"
#     with open(output_path, 'w') as f:
#         yaml.dump(yaml_content, f, default_flow_style=False, sort_keys=False)
#     logger.info(f"Created YAML file for {name}")
    
#     return yaml_content, output_path
#         chain_dict[target_id] = {
#             'id': target_id,
#             'sequence': target if type == 'protein'else None,
#             'smiles': target if type == 'small_molecule' else None,
#             'ccd': target if type == 'metal' else None,
#             'type': {
#                 'protein': 'protein',
#                 'small_molecule': 'ligand', 
#                 'dna': 'dna',
#                 'rna': 'rna',
#                 'metal': 'metal'
#             }[type],
#             'msa': 'empty' if type == 'protein' else None
#         }
#         # Remove None values
#         chain_dict[target_id] = {k:v for k,v in chain_dict[target_id].items() if v is not None}

#     return create_yaml_file(
#         pdb_code=name,
#         chain_dict=chain_dict,
#         yaml_target_ids=yaml_target_ids,
#         config=config,
#         use_msa=use_msa,
#         constraints=constraints,
#         modifications=modifications
#     )

# def create_yaml_file(pdb_code: str, chain_dict: dict, yaml_target_ids: list, config: Config, use_msa: bool = False, constraints: list = None, modifications: list = None) -> bool:
#     """Create YAML configuration file for protein chains, ligands, and nucleic acids.
    
#     Args:
#         pdb_code: PDB identifier
#         chain_dict: Dictionary mapping chain IDs to sequences or sequence info dicts
#         config: Configuration object
#         msa_chains: List of chains that have MSA data
#         constraints: Optional list of constraints to add to the YAML
#         modifications: Optional list of modifications to add to the YAML
#     """
#     sequences = []
#     for chain_id, sequence in chain_dict.items():
#         if isinstance(sequence, dict):
#             if sequence.get('type') == 'ligand':
#                 sequences.append({
#                     "ligand": {
#                         "id": [chain_id],
#                         "smiles": sequence.get('smiles')
#                     }
#                 })
#             elif sequence.get('type') == 'metal':
#                 sequences.append({
#                     "ligand": {
#                         "id": [chain_id],
#                         "ccd": sequence.get('ccd')
#                     }
#                 })
#             elif sequence.get('type') in ['dna', 'rna']:
#                 sequences.append({
#                     sequence.get('type'): {
#                         "id": [chain_id],
#                         "sequence": sequence.get('sequence')
#                     }
#                 })
#             else:  # protein
#                 msa_path = (config.MSA_DIR / f"{pdb_code}_{chain_id}_env/msa.npz" 
#                            if use_msa and not all(x == 'X' for x in sequence.get('sequence')) else "empty")
                
#                 protein_dict = {
#                     "id": [chain_id],
#                     "sequence": sequence.get('sequence'), 
#                     "msa": str(msa_path)
#                 }

#                 if modifications and chain_id in yaml_target_ids:
#                     protein_dict["modifications"] = modifications
                    
#                 sequences.append({"protein": protein_dict})
    
#     yaml_content = {
#         "version": 1,
#         "sequences": sequences
#     }
    
#     if constraints:
#         yaml_content["constraints"] = constraints

#     output_path = config.YAML_DIR / f"{pdb_code}.yaml"
#     with open(output_path, 'w') as f:
#         yaml.dump(yaml_content, f, default_flow_style=False, sort_keys=False)
#     logger.info(f"Created YAML file for {pdb_code}")
#     return yaml_content, output_path


    
def process_msa(chain_id: str, sequence: str, pdb_code: str, config: Config) -> bool:
    """Process MSA for a single chain."""
    msa_chain_dir = config.MSA_DIR / f"{pdb_code}_{chain_id}"
    env_dir = msa_chain_dir.with_name(f"{msa_chain_dir.name}_env")
    env_dir.mkdir(exist_ok=True)
    
    # Run MSA
    unpaired_msa = run_mmseqs2(
        [sequence],
        str(msa_chain_dir),
        use_env=True,
        use_pairing=False,
        host_url="https://api.colabfold.com",
        pairing_strategy="greedy"
    )
    
    # Save MSA results
    msa_a3m_path = env_dir / "msa.a3m"
    msa_a3m_path.write_text(unpaired_msa[0])
    
    # Process MSA if not already processed
    msa_npz_path = env_dir / "msa.npz"
    if not msa_npz_path.exists():
        msa = parse_a3m(
            msa_a3m_path,
            taxonomy=None,
            max_seqs=4096,
        )
        msa.dump(msa_npz_path)
    
    logger.info(f"Processed MSA for {pdb_code} chain {chain_id}")
    return True